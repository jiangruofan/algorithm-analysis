[Google Virtual Onsite Question](https://leetcode.com/discuss/interview-question/1797257/Google-Virtual-Onsite-Question)
implement probability(x,t) where x is an integer location on a 1d axis. we start from x=0 with probability of 1. We can go right, left, or stay where we are at each integer time step with probabilities p1, p2, 1-p1-p2. time increments as dt = 1. Every time you move right, left, or stay where you are (every action), time increments 1 unit.

答案:
```
class Solution:
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.p3 = 1-p1-p2
    def probability(self,x,t):
        # recursive time complexity O(xt)
        # space complexity O(xt)
        # At time 0 - pos 0
        if x == 0 and t == 0:
            return 1

        # if x = 5 or -5 and time = 3 i.e. reach position 5 or -5 by time 3 which is not possible
        # because we can only reach max x 3 in t 3
        # this should prune a lot of results
        if abs(x) > t:
            return 0

        out = 0
        out += self.probability(x-1,t-1) * self.p1
        out += self.probability(x+1,t-1) * self.p2
        out += self.probability(x,t-1) * self.p3

        return out
```

---------------------------

[Google OA](https://leetcode.com/discuss/interview-question/2616448/Google-OA)

**Minimum operations:**  
You are given an array A of N non-negative integers and an integer K. You can perform the following operation on this given array any number of times:  
• Choose an index i (1<=i<=N), and increase the element at this index by 1

Task Determine the minimum number of operations that needs to be performed, so that every subarray of size 3 or more has a maximum element, greater than or equal to K .

Example:  
n=4  
k=5  
a = [2,1,1,3]  
ans = 4

答案:
```
def solution(arr, k):
  leng = len(arr)
  @cache
  def dfs(index):
    if index >= leng - 3:
      max1 = max(arr[index:leng])
      return k - max1 if max1 < k else 0
    res = float('inf')
    for i in range(index, index+3):
      max1 = max(arr[index:i+1]) 
      res = min(res, (k - max1 if max1 < k else 0) + dfs(i+1))
    return res
  return dfs(0)
  ```

-------------

[Tough OA Question](https://leetcode.com/discuss/interview-question/2699186/Tough-OA-Question)

![image](https://assets.leetcode.com/users/images/1c76bc47-cc98-4192-a3fa-60afd310d305_1665678155.4840589.jpeg)
![image](https://assets.leetcode.com/users/images/6cb34eb3-1c9d-4e62-bcb1-ea4748aa20bc_1665678170.4263608.jpeg)
![image](https://assets.leetcode.com/users/images/c516be46-ffea-4966-a33a-0e0f282a1109_1665678180.0722504.jpeg)
![image](https://assets.leetcode.com/users/images/b0f3a76d-e1fc-45e9-8eec-f207faac7cfd_1665678182.5647662.jpeg)

![image](https://assets.leetcode.com/users/images/fe5b639b-988b-44c7-99a2-f1a5d5826b8f_1666102678.801102.png)

题目的关键点在于分割的小矩形必须和一条边相连接 也就是说中间不可能有一个被包围的矩形 那么分割后的所有小矩形一定可以通过大矩形竖着或者横着切一刀构成

-----



<!--stackedit_data:
eyJoaXN0b3J5IjpbMTg1MTk2Njg0OSwtMTk0NzIxNTk4MCw3OT
M0NzI5MzksMTg4ODcyNTI3NSwxNTQzNzc4MDc1LDczMDk5ODEx
Nl19
-->