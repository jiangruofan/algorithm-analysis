[Google Virtual Onsite Question](https://leetcode.com/discuss/interview-question/1797257/Google-Virtual-Onsite-Question)
implement probability(x,t) where x is an integer location on a 1d axis. we start from x=0 with probability of 1. We can go right, left, or stay where we are at each integer time step with probabilities p1, p2, 1-p1-p2. time increments as dt = 1. Every time you move right, left, or stay where you are (every action), time increments 1 unit.

答案:
```
class Solution:
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.p3 = 1-p1-p2
    def probability(self,x,t):
        # recursive time complexity O(xt)
        # space complexity O(xt)
        # At time 0 - pos 0
        if x == 0 and t == 0:
            return 1

        # if x = 5 or -5 and time = 3 i.e. reach position 5 or -5 by time 3 which is not possible
        # because we can only reach max x 3 in t 3
        # this should prune a lot of results
        if abs(x) > t:
            return 0

        out = 0
        out += self.probability(x-1,t-1) * self.p1
        out += self.probability(x+1,t-1) * self.p2
        out += self.probability(x,t-1) * self.p3

        return out
```

---------------------------

[Google OA](https://leetcode.com/discuss/interview-question/2616448/Google-OA)

**Minimum operations:**  
You are given an array A of N non-negative integers and an integer K. You can perform the following operation on this given array any number of times:  
• Choose an index i (1<=i<=N), and increase the element at this index by 1

Task Determine the minimum number of operations that needs to be performed, so that every subarray of size 3 or more has a maximum element, greater than or equal to K .

Example:  
n=4  
k=5  
a = [2,1,1,3]  
ans = 4

答案:
```
def solution(arr, k):
  leng = len(arr)
  @cache
  def dfs(index):
    if index >= leng - 3:
      max1 = max(arr[index:leng])
      return k - max1 if max1 < k else 0
    res = float('inf')
    for i in range(index, index+3):
      max1 = max(arr[index:i+1]) 
      res = min(res, (k - max1 if max1 < k else 0) + dfs(i+1))
    return res
  return dfs(0)
  ```

-------------

[Tough OA Question](https://leetcode.com/discuss/interview-question/2699186/Tough-OA-Question)

![image](https://assets.leetcode.com/users/images/1c76bc47-cc98-4192-a3fa-60afd310d305_1665678155.4840589.jpeg)
![image](https://assets.leetcode.com/users/images/6cb34eb3-1c9d-4e62-bcb1-ea4748aa20bc_1665678170.4263608.jpeg)
![image](https://assets.leetcode.com/users/images/c516be46-ffea-4966-a33a-0e0f282a1109_1665678180.0722504.jpeg)
![image](https://assets.leetcode.com/users/images/b0f3a76d-e1fc-45e9-8eec-f207faac7cfd_1665678182.5647662.jpeg)

![image](https://assets.leetcode.com/users/images/fe5b639b-988b-44c7-99a2-f1a5d5826b8f_1666102678.801102.png)

题目的关键点在于分割的小矩形必须和一条边相连接 也就是说中间不可能有一个被包围的矩形 那么分割后的所有小矩形一定可以通过大矩形竖着或者横着切一刀构成

-----

[Dynamic Programming Algorithm Google Interview Question](https://leetcode.com/discuss/interview-question/2720165/Dynamic-Programming-Algorithm-Google-Interview-Question)

I recently had a Google interview where they asked a dynamic programming question that I was not able to fully get. The question goes as follows:

To thank you for solving the game, your friend gives you a large chessboard as a gift.  
Unfortunately, the board has been assembled incorrectly, and some adjacent cells have the same color.

Additionally, the board is rectangular, and has width m and height n. As you like to avoid waste, you decide to fix the board.

A correct board has the following properties:

-   its width is equal to its height
-   no two adjacent cells of the board have the same color

You would like to fix the board to extract a maximum correct sub-board out of the original board.  
This may involve flipping the colors of some cells, i.e., inverting the color from white to black or from black to white.

More formally, given an arbitrary m × n input board, you must preprocess the board using an efficient algorithm that you design. After preprocessing, given a query w indicating the number of cells that you wish to flip, your algorithm must output the maximum size of a correct chessboard that can be constructed using at most w flips in O(1) time.

You can assume that m = Θ(n) for simplicity (note that this does not mean that they are exactly equal).  
Give a preprocessing algorithm that runs in O(n^3).

Argue that the overall query algorithm is correct and runs in the required time. Give a proof of correctness as well.

Any ideas on how to solve this question it really stumped me. Thanks in advance!

dp预处理 dp[i][j][k] 表示使得(0,0)到(i,j)这个矩形中两两元素不相同并且第(i,j)个元素是否翻转的最少翻转次数 k=0表示不翻转 k=1表示翻转
然后枚举正方形的边长 进行遍历



<!--stackedit_data:
eyJoaXN0b3J5IjpbOTU0MTIwMDA4LDE4NTE5NjY4NDksLTE5ND
cyMTU5ODAsNzkzNDcyOTM5LDE4ODg3MjUyNzUsMTU0Mzc3ODA3
NSw3MzA5OTgxMTZdfQ==
-->