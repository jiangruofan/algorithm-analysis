[Google Onsite Question](https://leetcode.com/discuss/interview-question/1918329/Google-Onsite-Question)

[Search Extensible String](https://aonecode.com/interview-questions/search-extensible-string)

[Google|Onsite|Search Extensible String](https://leetcode.com/discuss/interview-question/2934467/GoogleorOnsiteorSearch-Extensible-String)

I was asked this question on a google onsite. Given an index and an input string find the char at the given index of the string. But here's the catch: if the index exceeds the length of the string, then you transform the string by removing the string's last character and appending it to the front and appending this transformed string to the original string until you have a string length that exceeds the desired index.

For example,if we have a string "abcd" and want to find the char at index 3 it would obviously be 'd'. However, if we want to find the char at index 7 of "abcd" we would transform "abcd" to "abcddabc" and the char would be 'c'. If we want to find the char at index 12 of "abcd" we would transform "abcd" to "abcddabc" and then again transform to "abcddabccabcddab" and the char would be 'd.

I was only able to code it the brute force way but a O(logn) solution exists.

答案:
Yes. This can be done in O(log N) time. Before that observe the following. Let us take the indices in the example you gave  
a(0) b(1) c(2) d(3). The indices after each doubling would look like  
0 1 2 3  
0 1 2 3 | 3 0 1 2  
0 1 2 3 3 0 1 2 | 2 0 1 2 3 3 0 1  
First, by successive doubling in O(log N) time find out the length of the string required to compute the character.  
Recursively do the following

1.  If the character is in the right half of the string, then compute the position within the right half
2.  Then shift left by 1. Why? Because we want to discard the right half and find the corresponding position in the left half.
3.  Discard the right half until the position required is < len(S) where S is the original string.

-------

[Google | L3 | Onsite](https://leetcode.com/discuss/interview-question/930843/Google-or-L3-or-Onsite)

Round 1: Given a sorted n-size array, there are k elements have been changed i.e. [1, 3, 5, 6, 4, 2, 12] (it might be changed from [1, 3, 5, 6, 7, 8, 12] with k = 2). Important to know is that  **k is unknown and k is much smaller than n.**  The task is to re-sort the entire array.  
The interviewer wants O(n) solution. I bombed this one. In the end, the interviewer kind of fed the solution to me. What he suggested: a. break the array into two: one sorted array and one unsorted array e.g. [1, 3, 5, 12] and [6, 4, 2]. This takes O(n) b. Sort the unsorted array. This takes O(klogk) c. Merge two sorted arrays. This takes O(n). Because k is very small, so in the end O(n) + O(klogk) ~= O(n).

Round 2: First describe a situation you missed a deadline and what you have learnt from it. Then coding question: Card has 4 attributes (color, count, shading, shape), each attribute can have value 0, 1 or 2. 3 cards are considered as a set if for each attribute, 3 cards either have the same value or have different value from each other. For example:  
card1 (2, 0, 1, 2), card2 (1, 0, 0, 1) and card3(0, 0, 2, 0) are 1 set.  
card1(2, 0, 1, 2), card2 (1, 1, 0, 1) and card3(0, 1, 2, 0) are not 1 set.

1.  write a boolean function with 3 cards as input. This function returns true if they are 1 set, otherwise returns false.
2.  Now given a collection of cards, return true if there is a set of cards exsits, otherwise return false. The interviewer wants O(n^2) solution.

Round 3: Given an array i.e. [1, 2, 3, 5, 6, 7, 8] and a value k i.e. 3. If there is a subarray with length of 2k satisfies a sequence [a, a + 1, a + 2 ... a + k - 1, b, b + 1, b + 2... b + k - 1]. Return the beginning index of this subarray. So with given array [1, 2, 3, 5, 6, 7, 8] and k = 3, it can return 0 as [1, 2, 3, 5, 6, 7] satisfies the sequence requirement. If with given array [1, 3, 5, 6, 7, 8] and k = 3, it return -1 as there is no such subarray exsits.

答案:
1. 把k个元素找出来 然后排个序 然后重新插入 n + klogk 因为k很小
2. 使用bitmask 固定中间的一张card 计算所有可能元素 应该是81种情况
3. 预处理每个元素连续的最前面的元素是多少 然后滑窗遍历 

https://leetcode.com/discuss/interview-question/1250654/google-onsite

I found this stack overflow link  [https://stackoverflow.com/questions/62764861/how-to-sort-an-array-with-n-elements-in-which-k-elements-are-out-of-place-in-on](https://stackoverflow.com/questions/62764861/how-to-sort-an-array-with-n-elements-in-which-k-elements-are-out-of-place-in-on)  which summarises the solution:

1.  Find elements which are not sorted by traversing the array.
2.  If an element was found which is larger than the next one, then either it or the following one are out of order (or both).
3.  Keep both of them aside, and remove them from the array.
4.  Continue traversing on the newly obtained array (after removal), from the index which comes before the found element.
5.  This will put aside 2k elements in O(n) time.
6.  Sort 2k elements O(klogk)
7.  Merge two sorted lists which have total n elements, O(n)  
    Total O(n + klogk)

For the above array, the resulting arrays will be - [1, 3, 12] and [5, 6, 4, 2] ( 2k elements ). I think the above will give O(n) in worst case if (k << n).

------------------------------

[Google SWE Intern OA (SEA)](https://leetcode.com/discuss/interview-question/887761/Google-SWE-Intern-OA-%28SEA%29)

![image](https://assets.leetcode.com/users/images/5b6701c8-d38f-4e4d-bbd7-1be51c03c412_1602324741.0733693.png)

答案:
The solution of Q2 (only the algorithm), to solve it in linear time, so in O(V+E).  
the drawn pictures:  [https://imgur.com/a/DHl7qZ3](https://imgur.com/a/DHl7qZ3)  
case1.  
First suppose that in G there is no directed cycle:  
In that case let u[1],u[2],...,u[k] the vertices from 1..N with income degree=0. Since we have to reach them  
we surely need to use (at least) k new added edges that ends in these points, the (income) cost of these is  
s2=cost2[u[1]]+cost2[u[2]]+...+cost2[u[k]].  
Then let t that point from the cost is the smallest, so t=argmin(cost1[1],cost1[2],...,cost1[N+1]).  
If t=N+1, then bingo, the answer is s2+k*cost1[N+1], so add the (N+1,u[i]) edges to the graph. (see first picture)  
Else, so if t<=N, then let t reachable from u[p], then add (N+1,u[p]) to the graph and  
(t,u[i]) for all i!=p, the total cost of this is s2+cost1[N+1]+(k-1)*cost1[t]. (see 2nd pic)

case2.  
There are directed cycles in the graph. Good, detect them and contract it with the following way:  
if v[1],...,v[k] is in a strongly connected component (SCC), then replace the whole component with a single P point. And update cost1[P]=min(cost1[v[1]],cost1[v[2]],..,cost1[v[k]]), and cost2[P]=min(cost2[v[1]],cost2[v[2]],...,cost2[v[k]]). At the end there will be no directed cycle in the graph, hence you can apply case1. (see 3rd pic)

--------------

[Google OA For FTE](https://leetcode.com/discuss/interview-question/1402524/Google-OA-For-FTE)

Given an array of 0, 1, and 2's find the minimum number of swaps to be performed such that A[i] = i%3 (0 <= i <= n-1) for all i. If it is not possible return -1. N <= 10^5.

注意这里的互换不要求相邻之间的元素互换 所以可以对0,1,2对应的位置计算出有多少不同的元素 比如0 计算应该是0的位置上却是1和2的个数 然后计算应该是1的位置上却是0和2的个数 最后计算应该是2的位置上却是0个1的个数 然后先互相抵消 最后就剩下
本来是 0 1 2
             1 2 0
             2 0 1

--------------

[Google | OA](https://leetcode.com/discuss/interview-question/1586927/Google-or-OA)

Write a function

class Solution { public String solution(String S); }

which, given a string S consisting of lowercase letters of the English alphabet, returns the longest consistent fragment of S which begins and ends with the same letter. If there are many possible answers you should return the one starting at the earliest position.

```
    Examples:

    1. Given S = "cbaabaab", your function should return "baabaab".

    2. Given S = "performance", your function should return "erformance".

    3. Given S = "cat", your function should return "c".

    Write an efficient algorithm for the following assumptions:

    the length of S is within the range [1..100,000];
    string S consists only of lowercase letters (a−z).
```

只有26个字母 所以只需要 看每一个字符的左右边界即可

----

[Google Interview](https://leetcode.com/discuss/interview-question/1357725/Google-Interview)

如果最左边和最右边不一样 那么直接返回
如果一样 假设为val 那么就找左边和右边第一个和val不一样的元素

---------

[Google | Phone Screen | Second Max | Reject](https://leetcode.com/discuss/interview-question/423264/Google-or-Phone-Screen-or-Second-Max-or-Reject)

Given an array of integers, find the second max using only the function  `compare(a, b)`  that compares two integers and returns the maximum of the two. The solution must use the function  `compare(a, b)`  minimum number of times.

PS: You can assume that the array doesn't contain any duplicates and all the integers are positive

```
4  7  2  0  1  3  5  6

compare adjacent:
(4  7)  (2  0)   (1  3)  (5  6)

Array after each iteration: 
(4  7)  (2  0)   (1  3)  (5  6)        4 compare()
    (7       2)      (3      6)          2 compare()
         (  7            6  )                1 compare()

```

```
4  7  2  0  1  3  5  6

compare adjacent:
(4  7)  (6  0)   (1  3)  (5  2)

Array after each iteration: 
(4  7)  (6  0)   (1  3)  (5  2)        4 compare()
    (7       6)      (3      2)          2 compare()
         (  7            2  )                1 compare()
```

注意这里不需要考虑时间复杂度 题目要求的是compare次数最少
次数最少是 n - 1 (计算最大) + logn - 1 (计算次大)
为什么两两比较不行? 两两比较计算最大也是 n - 1 但是计算次大不是logn 最好情况是O(1) 最差情况是O(n) 所以使用树形结构二分可以保证logn
[https://stackoverflow.com/questions/3628718/find-the-2nd-largest-element-in-an-array-with-minimum-number-of-comparisons](https://stackoverflow.com/questions/3628718/find-the-2nd-largest-element-in-an-array-with-minimum-number-of-comparisons)

--------------


[Google | OA | SDE (2020)| India](https://leetcode.com/discuss/interview-question/805468/Google-or-OA-or-SDE-%282020%29or-India)

You are given an array of N elements. You are allowed to delete at maximum one element from the provided array. The order of elements remains the same in the resultant array. You are required to maximize the number of subarrays that contain both maximum and minimum elements of the resultant arary.  
    **Constraints**  
    TestCases [1,10]  
    N [1,105]  
    1<= arri<=109

```
Input
6
7 2 5 4 3 1
Output
4
Explaination
If we delete 1 from the array then resultant arary will be 7 2 5 4 3. So the number of subarrays which will contain maximum 7 and minimum 2 will be 4
[7,2]
[7,2,5]
[7,2,5,4]
[7,2,5,4,3]
```

只需要找到最中间的最大值和最小值 然后就是求数量 假设位置为(i, j) 数组长为n 那么数量为 i * (1 + 2 + 3 + .... n-j) 

-------------

[Google Phone Screen Round](https://leetcode.com/discuss/interview-question/494288/Google-Phone-Screen-Round)

1.  Imagine an array class with only 3 operations GetAt(), SetAt() and SetAll(). Implement all the methods as O(1).
2.  Given denominations D and a max value MAX, find the smallest set of coins that can exactly construct any value 1 <= n <= MAX.

**_The explanation goes like this.  
D is a vector, sorted increasing, which describes the monetary system; e.g. {1, 5, 10, 25} for a U.S. penny, nickel, dime, quarter.  
MAX is in the same units as D.  
The output should be a vector of the same order as D, where each coefficient is how many of that coin you have. "Smallest set" refers to the total number of coins in the set. Some inputs may have multiple equally good answers; you may choose any such answer.

答案: 1.用一个字典存储 true false 即可
2. 油管面试题一样的 贪心思想

------------

[Google | Tree Game](https://leetcode.com/discuss/interview-question/294183/Google-or-Tree-Game)

LC version is slightly different:  [https://leetcode.com/problems/binary-tree-coloring-game](https://leetcode.com/problems/binary-tree-coloring-game)

Two people in a game, player scores by claiming nodes in binary tree.

```
class TreeNode { 
    int val; // only used to uniquely identify a node
    TreeNode parent;
    TreeNode left;
    TreeNode right;
	// you can add more fields if you want
} 

```

The player who eventually owns more nodes wins the game.  
Player A and B each claims a node at first.  
After the first round, a player will only be able to claim a node adjacent to any node owned by himself.  
A tree node is adjacent to its parent, left right and right child.  
A node owned cannot be re-claimed.  
End game when all nodes are owned.  
If player A gets the first claim at node N, find whether it is possible for player B to win.  
If yes, find out which node player B should claim at his first move.

**Follow-up:**  
If player B takes the first hand instead, which node should he pick?

答案: 一定是下在player A 的父节点 左子节点或者右子节点 分别计算对应3部分的节点数 只要比总数的一半多 那么就可以 follow up没啥意思 谁先手谁后手没区别的

-------

[Google OA 2022](https://leetcode.com/discuss/interview-question/2616381/Google-OA-2022)

This was the second question. I was not able to do this one.  
The question was as follows  
Given string of length n find alphabetically largest subsequence of length i for each i between 1 to n. [NOTE: subsequence, not subarray]  
Example:  
s = "hrw"

ans = ["w","rw","hrw"]

I don't exactly remember the constraints, but I guess n was around 1000.  
How to do this problem?  
Thanks

答案: 
TC: O(n^2)  
Extra space: O(n^2)

```
def fun(s):
    n=len(s)
    max_ij=[[-1]*n for i in range(n)] #gives the 0 based index of the max character in s[i:j+1]
    for i in range(n):
        for j in range(i,n):
            if i==j:
                max_ij[i][j]=i # initialize
            else:
                if s[j]>s[max_ij[i][j-1]]:
                    max_ij[i][j]=j # update if new max character found
                else:
                    max_ij[i][j]=max_ij[i][j-1]
    ans=[]
    for length in range(1,n+1):
        curr_ans=[]
        start=0
        for left in reversed(range(1,length+1)):
            max_index=max_ij[start][n-left] # get the max character in s[start:n-left+1] in O(1) because we still need left characters so can't utilize last left characters
            curr_ans.append(s[max_index])
            start=max_index+1
        ans.append("".join(curr_ans))
    return ans

s="hrwaw"
ans=fun(s)
print(ans)

```

Space complexity can be further reduced by using Range Query and printing output and for each length

-------------

[The Celebrity Problem](https://leetcode.com/discuss/interview-question/2607522/The-Celebrity-Problem)

**The Celebrity Problem**

_**Please upvote if you like it!!!!!!!!!!!!**_

**Problem Statement:-**  A celebrity is a person who is known to all but does not know anyone at a party. If you go to a party of N people, find if there is a celebrity in the party or not. A square NxN matrix M[][] is used to represent people at the party such that if an element of row i and column j is set to 1 it means ith person knows jth person. Here M[i][i] will always be 0.

-   Note: Follow 0 based indexing.
-   Follow Up: Can you optimize it to O(N)

**Input:**

-   N = 3
-   M[][] = {{0 1 0},  
    {0 0 0},  
    {0 1 0}}

**Output:**  1  
**Explanation:**  0th and 2nd person both know 1. Therefore, 1 is the celebrity.

**C++ Code:-**

```
//Function to find if there is a celebrity in the party or not.
    bool knows(int a, int b,vector<vector<int> >& M){
        if(M[a][b]==1) return true;
        return false;
    }
    int celebrity(vector<vector<int> >& M, int n) 
    {
        // code here 
        stack<int> st;
        for(int i=0;i<n;i++){
            st.push(i);
        }
        while(st.size()>1){
            int a=st.top();
            st.pop();
            int b=st.top();
            st.pop();
            if(knows(a,b,M))// A knows B
                st.push(b);
            else
                st.push(a);
        }
        int Candidate=st.top();
        
        //Row check
        int rowCount=0;
        for(int i=0;i<n;i++){
            if(M[Candidate][i]==0)rowCount++;
        }
        
        if(rowCount != n) return -1;
        
        //Column check
        int colCount=0;
        for(int i=0;i<n;i++){
            if(M[i][Candidate]==1) colCount++;
        }
        
        if(colCount != n-1) return -1;
        
        return Candidate;
    }
```

------

[Microsoft Online assessment question 5 tasks in 90 min](https://leetcode.com/discuss/interview-question/2214338/Microsoft-Online-assessment-question-5-tasks-in-90-min)

![image](https://assets.leetcode.com/users/images/7a823aa8-6289-4f12-b077-18baaa4e2226_1656517168.748914.png)

从小到大遍历即可 并且用一个hash表保存需要删除的元素

--------

[Microsoft | OA | Number of Slices to sort an array](https://leetcode.com/discuss/interview-question/1937426/Microsoft-or-OA-or-Number-of-Slices-to-sort-an-array)

Given integer array A[] with distinct elements. Find max number of slices in which array can be divided, so that if all slices are combined, we get a complete sorted array. Each slice need to be sorted individually, and then these sorted slices should be combined.  
Ex1. A=[2,4,1,6,5,9,7]. Ret val = 3. slices[2,4,1], [6,5], [9,7]  
Ex2. A=[4,3,2,6,1]. Ret val =1. Array cannot be sliced.  
Ex3. A=[2,1,6,4,3,7] Ret val =3. slices [2,1], [6,4,3],[7]

What logic can be used here to slice the arrays?

当前区间的最大值一定要大于后面的最小值 否则就可以切割了
类似 snowflake的 array reduction

-----------

[Atlassian | OA | maximum MEX](https://leetcode.com/discuss/interview-question/2703072/Atlassian-or-OA-or-maximum-MEX)

Given an array containing n non negative integers and an element x, In one operation, x can be added to or subtracted from any element of the array. MEX of an array is defined as the smallest non negative integer which is not present in the array. for example, the MEX of [0,1,1,3] is 2, and the MEX of [1,2,4] is 0

Find the maximum possible MEX of the array that can be achieved by doing the above operation any number of times

**Explanation**  
arr = [0,1,2,1,3]  
x = 3  
if we add x to arr[1] we get arr = [0,4,2,1,3] having MEX equal to 5.  
this is the maximum possible MEX that can be achieved

**Constraints**  
1 <= n <= 10^5  
0 <= arr[i] <= 10^9  
1 <= x <= 10^5

**testcase 0:**  
3 //value of n  
1 3 4  
2 //value of x  
**output:**  
2  
**explanation:**  
by subtracting x from arr[2] two times, arr = [1,3,0] that has MEX 2, the maximum possible MEX

**testcase 1:**  
7  
0 1 2 2 0 0 10  
3  
**output:**  
7  
**explanation:**  
arr can be transformed into [0,1,2,5,3,6,4,3] that ha MEX=7, the maximum possible

答案 将所有数字对x取模存到hashmap 然后从1开始遍历

-----

[Microsoft OA | India](https://leetcode.com/discuss/interview-question/2247302/Microsoft-OA-or-India)

[https://stackoverflow.com/questions/68859514/how-can-i-find-and-format-visually-aesthetically-pleasant-pattern-of-trees-in-a](https://stackoverflow.com/questions/68859514/how-can-i-find-and-format-visually-aesthetically-pleasant-pattern-of-trees-in-a)

There are examples of aesthetically pleasing trees:
![enter image description here](https://i.stack.imgur.com/UeWkz.png)
These are examples of not aesthetically pleasing trees
![enter image description here](https://i.stack.imgur.com/cfU5Q.png)

That, given an array A consisting of N integers, where A[K] denotes the height of the K-th three, returns the number of ways of cutting out one tree, so that the remaining trees aesthetically pleasing. If it is not possible to achieve the desired result, your function should return -1. If the trees are already aesthetically pleasing without any removal your function should return 0.

Expected Result A1 = [1, 2, 3, 4, 2, 5]; This pattern can never be form visually aesthetical so, function should return -1.

Expected Result A2 = [1, 3, 1, 2]; this pattern is already in visually aesthetically pleasant so it should return 0.

答案:
节点2一定能被删除
节点1删除 必须节点2小于节点0
节点3删除 必须节点4小于节点2

https://www.autodraw.com/share/5BK1QW1JR6E5

-----------

[Microsoft | SDE-1 | OA 2022](https://leetcode.com/discuss/interview-question/2055241/Microsoft-or-SDE-1-or-OA-2022)

**You are given a positive Integer N, your task is to find the next smallest integer greater than N that does not contain two identical consecutive digits**

ex:  **N=1765 -> 1767**  beause 1766 has two identical consecutive digits  
**N=54 -> 56**  not 55 because two identical digits

1. 如果n本身就包含2个重复的 那么找到最前面的两个相同的 如果数字不是99 那么直接第二个数字加1 后面都替换成01010101
2. 如果n本身不包含两个重复的 那么n直接加1 如果没有出现重复的 那么直接就是答案 如果出现重复的 那么就是第一种情况了

---------

[Microsoft | OA | May 2022](https://leetcode.com/discuss/interview-question/2060042/Microsoft-or-OA-or-May-2022)

![image](https://assets.leetcode.com/users/images/56105fdb-be46-47eb-8d78-cff00901dbd5_1653134827.2047198.png)

首先从左到右 如果某个5后面的数字大于5 那么就删除这个5
如果所有5的后面的数字都小于5 那么就删除最后一个5
如果5后面还是5 那么直接跳过
负数同理

-----------

[Amazon OA | September 2022](https://leetcode.com/discuss/interview-question/2532488/Amazon-OA-or-September-2022)

I got following two question in Amazon OA

-   [Minimum Swaps required to make binary string palindrome](https://devsolus.com/2022/04/26/minimum-number-of-swaps-required-to-make-a-binary-string-palindrome/)  
    e.g i/p = 11001, o/p = 1 , Explanation -> 1 swap to make 11001=>10101
-   Sum of total server power, which is the same as  [https://leetcode.com/problems/sum-of-total-strength-of-wizards/](https://leetcode.com/problems/sum-of-total-strength-of-wizards/)

------

[Tiktok OA](https://leetcode.com/discuss/interview-question/2646621/Tiktok-OA)

![image](https://assets.leetcode.com/users/images/a1eccd6f-0646-4aef-a183-00bc7c2d3790_1664640163.776837.png)

前缀和的前缀和 和那个wizard很像

------

[Google OA | step-intern](https://leetcode.com/discuss/interview-question/2675660/Google-OA-or-step-intern)

```
Q2. Given a binary array of 0s/1s count all subarrays having atleast one 0. 
Also maximum one operation is allowed to convert 1 => 0 for any element in the given array 
such that the number of subarrays with at least one 0 is maximized. 
```
011111 [1] 11110
考虑把当前的1变成0
那么新增的个数为 当前位置到前一个0的位置的距离 ✖️ 当前的位置到后一个0的距离

-----

[Google Singapore Internship OA Round for 2023 | 8th oct | Solutions attached](https://leetcode.com/discuss/interview-question/2675295/Google-Singapore-Internship-OA-Round-for-2023-or-8th-oct-or-Solutions-attached)

![image](https://assets.leetcode.com/users/images/2c40f434-2e41-4835-81ad-4fccfacab5ef_1665213558.4241586.png)

1. 考虑c上为1的bit 那么a和b都必须为1 不然的话x为1
2. 考虑c上为0的bit 那么a和b都不能同时为1 不然的话答案不存在

![image](https://assets.leetcode.com/users/images/e35f8fdf-2694-4638-ad73-744fcf440546_1665213597.7875247.png)

Q2 greedily assign the smallest digit to the alphabet with the highest coefficient

A1A + 2AB=A*111+B+210

A can not be 0 due to no leading zero, give it 1  
B is 0

------

[Salesforce | Intern | OA | 2023 | hackerrank](https://leetcode.com/discuss/interview-question/2678306/Salesforce-or-Intern-or-OA-or-2023-or-hackerrank)

```
Question 1: ASCII Encoded Strings
Given a string, decode it following the steps mentioned below
	i) reverse the given string
	ii) convert the numerical representation to ascii characters
		The value range of A to Z is 65 to 90
		The value range of a to z is 97 to 122
		The value of space is 32
		
Input: 
encoded_string = "23511011501782351112179911801562340161171141148"
output = "Truth Always Wins"
```

如果是6到9开头 那么就是两位数 如果是1开头就是三位数

-----

[Morgan Stanley OA | SDE-1](https://leetcode.com/discuss/interview-question/2682330/Morgan-Stanley-OA-or-SDE-1)

**Question - 1 : Maximum Gross Value**

Given an array arr of n integers, for a triplet of indices i[1], i[2], i[3] (1<=i[1] <= i[2] <= i[3] <=n), grossValue(i[1], i[2], i[3]) = sum[1, i[1]) - sum[i[1], i[2]) + sum[i[2], i[3]) - sum[i[3], n+1)

Here sum[l,r) (1<=l <=r <= n+1) is the sum of all the elements in the subarray arr[l,r) i.e. sum[l,r) = arr[l] + arr[l+1] + ..... + arr[r-1]. Note that sum[l,r) is 0 as arr[l,l), is an empty subarray.

Find the maximum gross value of any valid triplet.

_Example:_  
arr = [-5,3,9,4]

Some gross value calculations (table) - ($ represents column wise seperated):  
**i[1] $ i[2] $ i[3] $ Gross Value**  
2 $ 3 $ 4 $ (-5)-(3) + 9 - 4 = 3  
1 $ 3 $ 4 $ 0 - (3) + 9 - 4 = 7  
1 $ 2 $ 4 $ 0 - (-5) + 16 - 0 = 21

```
 For row 1, arr[1,2) - arr[2,3) + arr[3,4) - arr[4,5) is shown.
 
 The maximum possible gross value is 21 for indices 1,2, and 5.

```

_Please explain the question, I was able to solve other coding questions & other MCQs except this one. I didn't understand the question._

遍历中间点 求出左半部分和右半部分的最大值 加起来即可
对于左半部分 假设新来了一个数字 那么最大值只有可能是两种情况 第一种情况就是 新来的值加成负数 那么就是前一个最大值-新来的值 第二种情况就是 从第一个值到新来的值都为sum[1, i[1])这一部分 那么就是sum1 + 新来的值

------

[Tough OA Question | Got TLE](https://leetcode.com/discuss/interview-question/2704156/Tough-OA-Question-or-Got-TLE)

![image](https://assets.leetcode.com/users/images/15fbd5ea-71f3-4b38-9f18-13e52496e2a9_1665784465.997331.png)
本质就是把所有的人先放到位置上去 然后从后往前 先来后到 每个人往后一个位置

    from collections import defaultdict
    arr=[7,3,11,3,4,3,11,7,5,6,1,4,2,8,4,3,5,5,3,2,6,1]
    
    res = [0 for _ in range(len(arr))]
    
    dic = defaultdict(list)
    for i in range(len(arr)):
        dic[arr[i]].append(i+1)
    
    for key in sorted(dic):
        print(key, dic[key])
    
    stack = []
    for key in sorted(dic, reverse=True):
        print(stack)
        begin = key
        for val in dic[key]:
            if stack and begin == stack[-1][0]:
                begin = stack[-1][1]
                stack.pop()
            res[val-1] = begin
            begin += 1
        if stack and begin == stack[-1][0]:
            begin = stack[-1][1]
            stack.pop()
            
        stack.append((key, begin))

print("-----------")
print(res)
print([7, 3, 11, 17, 4, 18, 12, 9, 5, 6, 1, 15, 2, 8, 16, 19, 13, 14, 20, 21, 10, 22])

------
 
 [Difficult OA Question](https://leetcode.com/discuss/interview-question/2717043/Difficult-OA-Question)
https://leetcode.com/discuss/interview-question/2683610/EBay-OA-2023-SDE-Intern

How do you solve this question?

You have  **nServers**  number of servers that handle requests in the cyclic order using the following logic:

-   The first request is handled by the first server.
-   The following requests are each handled by the next server that is not under maintenance.
-   When the last server is reached and you need to find the next server, proceed with the first one.

Also, you have a list of strings events. An event can be one of the following:

-   "**REQUEST**" - user request that is passed to some server; the operation takes 1 second.
-   "**UP < i >**" - ith server is manually restarted; the operation takes 0 seconds.

You're also given the following information:

-   **workLimit**  - the number of handled requests after which the server goes down for maintenance, and it will start handling requests once it rests for  **recoveryTime**  number of seconds or is started manually with the  **UP**  command.
    
-   **recoveryTime**- the number of seconds that the server stays under maintenance before being restarted automatically
    

Given the logic how requests are processed

-   At each step, if server k is up and hasn't reached the worklimit number of requests, the server handles that request. Otherwise, the server is bypassed.
-   It takes one second to serve a single request.

Return the server index that has served most of the requests. In the case of a tie, return the largest one.

**Notes**:

-   When some server k is under maintenance, it should be bypassed during handing requests
-   It is guaranteed that there is at least one functioning server to handle request
-   It is guaranteed that there is at least one "**REQUEST**" event.

简单模拟即可，就是时间戳

-----

[Expedia OA Summer 2023 Software Engineering Intern - Hard?](https://leetcode.com/discuss/interview-question/2744346/Expedia-OA-Summer-2023-Software-Engineering-Intern-Hard)

![image](https://assets.leetcode.com/users/images/f50b5a5e-31ac-4393-a844-30d6fb437cec_1666746504.4914222.png)

所有的正偶数加起来 正奇数看有多少个 偶数直接全加 奇数的话分两种情况 1. 奇数全加 再加一个最大的负奇数 2. 奇数全加去掉最小的奇数

----

[Microsoft | OA | MaximumSum](https://leetcode.com/discuss/interview-question/1770045/Microsoft-or-OA-or-MaximumSum)

```
You are given a string S, which consists entirely of decimal digits (0−9). 
Using digits from S, create a palindromic number with the largest possible decimal value. 
You should use at least one digit and you can reorder the digits. 

A palindromic number remains the same when its digits are reversed; for instance, "7", "44" or "83238". 
Any palindromic number you create should not, however, have any leading zeros, such as in "0990" or "010".
For example, decimal palindromic numbers that can be created from "8199" are: 
"1", "8", "9", "99", "919" and "989".

Among them, “989” has the largest value.

Write a function:
class Solution { public String solution(String S); }
that, given a string S of N digits, returns the string representing the palindromic number with the largest value.
Examples:
1. Given "39878", your function should return "898".
2. Given "00900", your function should return "9".
3. Given "0000", your function should return "0".
4. Given "54321", your function should return "5".
Write an efficient algorithm for the following assumptions:
N is an integer within the range [1..100,000];
string S consists only of digits (0−9).
```

对0-9进行次数统计 从大到小偶数次添加 最后添加一个最大的奇数次数

---

[Door Dash OA question](https://leetcode.com/discuss/interview-question/2773298/Door-Dash-OA-question)

![image](https://assets.leetcode.com/users/images/c1ce382b-423a-4398-b214-c744dc3a5f40_1667468943.36355.jpeg)
![image](https://assets.leetcode.com/users/images/5d349f02-e1cf-4762-8471-0d3b70b008ec_1667468943.317719.jpeg)

-------

[Microsoft Interview question](https://leetcode.com/discuss/interview-question/1756205/Microsoft-Interview-question)

Given two binary trees A and B with numbers convert tree A to tree B by using arithmetic operations (+, -, *, /) on any 2 nodes of A. If not possible return -1.

For example:  
A can be

```
       1
    2     3   

```

B can be

```
      8
2          6

```

and B can obtained from A as

```
    1                          7                   14                    8
2     6          =>          2    6    =>       2       6       =>   2      6

```

then A==B return 0

I went crazy solving this problem. I gave a brute force answer which he did not like that much. Anyone knows how to solve this ..?

只要不是一棵树全是0 另一棵树不全是0 答案就一定是true

-----

[Please help. Online Assessment question](https://leetcode.com/discuss/interview-question/2750072/Please-help.-Online-Assessment-question)

![image](https://assets.leetcode.com/users/images/0379eb26-083d-461e-9392-b2ec9cf31592_1666896698.2908926.png)
![image](https://assets.leetcode.com/users/images/3fc4da88-69db-447e-97a2-228f1ed7ceea_1666896723.816257.png)

枚举最高的位置即可 时间复杂度n^2

----

[Google Online Assessment Question](https://leetcode.com/discuss/interview-question/2770788/Google-Online-Assessment-Question)

Given a  `NxN`  matrix. Fill the integers from  `1`  to  `n*n`  to this matrix that makes the sum of each row, each column and two diagonals equal.

**Example 1:**

```
Input: n = 2
Output: null
Explanation: We need to fill [1, 2, 3, 4] into a 2x2 matrix, which is not possible so return null.

```

**Example 2:**

```
Input: n = 3
Output:
[[8, 3, 4],
 [1, 5, 9],
 [6, 7, 2]]
Explanation: We need to fill [1, 2, 3 ... 9] into a 3x3 matrix. There is one way to do it
Each row [8, 3, 4] [1, 5, 9] [6, 7, 2] sum is 15.
Each column [8, 1, 6] [3, 5, 7] [4, 9, 2] sum is 15.
The two diagonals [8, 5, 2] [4, 5, 6] sum is 15.
```

https://www.geeksforgeeks.org/magic-square/

-----

[TikTok OA](https://leetcode.com/discuss/interview-question/2779493/TikTok-OA)

![image](https://assets.leetcode.com/users/images/e1668213-0bae-4a6f-b7ee-56042ed0237e_1667603866.3509557.png)

---

[FAANG OA](https://leetcode.com/discuss/interview-question/2781828/FAANG-OA)

you are given an array a where all nunbers are distinct and whose valyes range in between 1to n . the only operation allowed on the array is : pick two indices i and j such that abs(Ai-Aj) = 1 and swap values at these indices. we now want to sort this array in ascending order. please write a code to find out the minimum operations requiredto acheive a sorted array

How to solve this?? it is a greedy question.  
pls do provide the proof of correctness of solution.

-----

[Microsoft Codility Online Assessment NOV 2022 3h 4 Questions](https://leetcode.com/discuss/interview-question/2778329/Microsoft-Codility-Online-Assessment-NOV-2022-3h-4-Questions)

Let's consider the following infinite sequence:  `0, 1, 1, 2, 3, 5, 8, 13, 12, 7, 10, 8, 9, ...`  
The 0th element is 0 and the 1st element is 1. The successive elements are defined recursively. Each of them is the sum of the separate  _**digits**_  of the two previous elements.

-   Given N = 2, the function should return 1.
-   Given N = 6, the function should return 8.
-   Given N = 10, the function should return 10.

存在循环节 如果大于10 一定可以转换到1-10中的一个数 那么循环节最多200个数字就会出现

----

[NinjaCart OA questions](https://leetcode.com/discuss/interview-question/2776690/NinjaCart-OA-questions)

![image](https://assets.leetcode.com/users/images/89430d2a-0507-4d66-af84-cac5544b1a63_1667545596.6804638.jpeg)
![image](https://assets.leetcode.com/users/images/d3919cea-675a-43f2-b6ac-7d721ffc1c15_1667545597.9770675.jpeg)

a b c 要求全部能整除3
全部是1 -- 全部是2 -- 0和1都有 -- 1和2都有 -- 0和2都有 -- 0和1和2都有
a b c 要求全部不能整除3 不能有0

---

[Media.Net | SDE Technical Interview | A Trie Question](https://leetcode.com/discuss/interview-question/1447833/Media.Net-or-SDE-Technical-Interview-or-A-Trie-Question)

We have given four strings, w, x, y, and z.  
We are allowed to change any of the four given strings to any one of their permutations respectively.  
So we want to get a permutation of each of fours strings such that after inserting them in a trie number of nodes in trie is minimum.

**Test Case:**

```
w = "abac"
x = "bac"
y = "cab"
z = "acb"

// If we permute them to
w = "abca"
x = "abc"
y = "abc"
z = "abc"

// then the trie will have only four nodes.
```

[https://www.hackerearth.com/practice/algorithms/greedy/basics-of-greedy-algorithms/practice-problems/algorithm/minimize-nodes-15f14b04/](https://www.hackerearth.com/practice/algorithms/greedy/basics-of-greedy-algorithms/practice-problems/algorithm/minimize-nodes-15f14b04/)

刚开始4个 寻找所有的公共字母 然后拆分成 2 2 和 3 1
2可以拆分成 1 1 
3可以拆分成 2 1

---

[Media.NET FTE OA](https://leetcode.com/discuss/interview-question/2674528/Media.NET-FTE-OA)

![image](https://assets.leetcode.com/users/images/1e108b70-93b4-452f-9031-30f4656973f6_1665199243.7490172.png)

从最高的开始排 然后插入就完事了 时间复杂度O(n^2)

---

[Google | Phone | Sort array by frequency in O(1) space](https://leetcode.com/discuss/interview-question/2837444/Google-or-Phone-or-Sort-array-by-frequency-in-O%281%29-space)

Given a sorted array, sort the array by frequency in O(1) space.

Example:  
`[1, 2, 3, 3, 3, 4, 4, ]`  
Result:  
`[3, 3, 3, 4, 4, 2, 1]`  
or  
`[3, 3, 3, 4, 4, 1, 2]`

因为是排好序的 所以n^2 可以解决 先求出当前当前最高频率元素的开始位置和频次 然后再进行数字移动即可

----

[Walmart Question](https://leetcode.com/discuss/interview-question/2896001/Walmart-Question)

[https://codeforces.com/problemset/problem/600/C](https://codeforces.com/problemset/problem/600/C)

考虑出现次数是奇数的字符 然后把字典序大的变成小的

---

[Media.net interview on campus Associate software role](https://leetcode.com/discuss/interview-question/2823856/Media.net-interview-on-campus-Associate-software-role)

```
Given array of strings.
Find count of combination of strings which would combine to form palindrome string

Interchange of alphabets is allowed
I  wasn't able to figure out, any approch?
```

类似上题

---

[HRT OA Questions](https://leetcode.com/discuss/interview-question/1520260/HRT-OA-Questions)

I remembered one question asked by HRT!!! And I still CANNOT figure it out!!! Huge thanks to anyone who can answer this question or find similar leetcode question!

Given a m*n 2d matrix, filled with pos numbers. Place 2 roosters on the matrix, and they cannot be in the same row or col. The value is the total sum EXCEPT rows/columns that rooster is placed. Find the maximum value after placing 2 roosters.

Example:

1 2 3 "X" denoted as rooster  
4 5 6  
7 8 9

1 X 3  
X 5 6  
7 8 9

The the value is 9 (thanks for that!)

预处理所有的列的和 枚举行 然后遍历一遍列 计算出最小的两个值 
时间复杂度是O(n^3)

----

[media.net | OA | on campus | associate software role](https://leetcode.com/discuss/interview-question/2815830/media.net-or-OA-or-on-campus-or-associate-software-role)

![image](https://assets.leetcode.com/users/images/ee8a4540-3d8c-4c12-adce-04b3a72fc051_1668487169.1663826.jpeg)

预处理 从左到右 计算出到ith的左括号个数和多余的左括号个数
对于某个区间的正确的括号数量 就是这个区间的左括号个数减去多余的左括号个数

---

[De Shaw OA ( bitwise )](https://leetcode.com/discuss/interview-question/2924975/De-Shaw-OA-%28-bitwise-%29)

![image](https://assets.leetcode.com/users/images/c974cdc9-9f39-4a05-92b2-d6a160831ad1_1671358995.681222.png)

时空倒流 时间复杂度应该是O(n^2)

-----

[Thailand Bank | Backend Developer | Special Tree](https://leetcode.com/discuss/interview-question/2939993/Thailand-Bank-or-Backend-Developer-or-Special-Tree)

In Today’s class, Chef is here to teach students about Trees. Tree is a a connected graph of N nodes and N-1 edges.

After class, Chef gave them an assignment to complete. Assignment is as follows :-

Given a tree with single node (root), we need to find whether we can build a tree with exactly N leaf nodes by applying given queries.

Query 1 : Choose any i in between 2 to K and any leaf node say L in current Tree, attach i leaf nodes to L. (We can choose any particular i only once)

Query 2 : Choose an existing edge of Tree and cut the edge. Remove the entire sub-tree attached with that edge.

Students need to answer T independent test cases. Can you help them ?

Example

-   If K = 5, N = 6. One possible way to build a tree with N = 6 leaf nodes is :-
    -   Query 1 : i = 5, leaf node = root. Now, there are 6 nodes in tree and 5 leaf nodes.
    -   Query 1 : i = 2, choose any of the 5 leaf nodes. Now, there are 8 nodes in tree and leaf nodes.
-   If K = 2, N = 3. It is not possible to build tree with 3 leaf nodes using given queries.

Function Description

-   K: Represents the maximum value of i allowed in Query 1.
-   N: Represents the required number of leaf nodes.

Input Format :-

1.First line contain an integer T (1 <= T <= 105)  
2.Next T line consist of two space separated integers K and N  
(2 <= K <= 10^5, 1 <= N <= 10^11)

Example:  
Input:  
2  
2 3  
7 5

Output:  
0  
1

第二个条件是没用的 只要计算1 + sum(1..k-1) >= n 即可

----

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTE5NzM4NjMwNywtMTgzODM5OTM5OSwtNz
M2ODgyMDg4LDE1NDA2Nzc2MywxNTUyMzA5MDg2LC0xMTYzMDY4
OTIxLDE5Nzc1OTI4MzksLTEyNTUzNjIzODksMTU0NDU2ODc4Ni
wxOTAwNjc5NzE3LC0xMDA1NjA0NjYxLDQ0MTg5NjAyMywyNDc3
NzM3NjMsLTEzNTQxNTk3MjksMTkzMDg3OTc5MSwtMTE5NTU4Nj
IzOCwtNjA3ODkwNDQyLC0xODUwMzIzNjI3LDQ1NjkzMTU1Nywt
OTEyODI2MTEwXX0=
-->