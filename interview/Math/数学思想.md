[Google Onsite Question](https://leetcode.com/discuss/interview-question/1918329/Google-Onsite-Question)

I was asked this question on a google onsite. Given an index and an input string find the char at the given index of the string. But here's the catch: if the index exceeds the length of the string, then you transform the string by removing the string's last character and appending it to the front and appending this transformed string to the original string until you have a string length that exceeds the desired index.

For example,if we have a string "abcd" and want to find the char at index 3 it would obviously be 'd'. However, if we want to find the char at index 7 of "abcd" we would transform "abcd" to "abcddabc" and the char would be 'c'. If we want to find the char at index 12 of "abcd" we would transform "abcd" to "abcddabc" and then again transform to "abcddabccabcddab" and the char would be 'd.

I was only able to code it the brute force way but a O(logn) solution exists.

答案:
Yes. This can be done in O(log N) time. Before that observe the following. Let us take the indices in the example you gave  
a(0) b(1) c(2) d(3). The indices after each doubling would look like  
0 1 2 3  
0 1 2 3 | 3 0 1 2  
0 1 2 3 3 0 1 2 | 2 0 1 2 3 3 0 1  
First, by successive doubling in O(log N) time find out the length of the string required to compute the character.  
Recursively do the following

1.  If the character is in the right half of the string, then compute the position within the right half
2.  Then shift left by 1. Why? Because we want to discard the right half and find the corresponding position in the left half.
3.  Discard the right half until the position required is < len(S) where S is the original string.

-------

[Google | L3 | Onsite](https://leetcode.com/discuss/interview-question/930843/Google-or-L3-or-Onsite)

Round 1: Given a sorted n-size array, there are k elements have been changed i.e. [1, 3, 5, 6, 4, 2, 12] (it might be changed from [1, 3, 5, 6, 7, 8, 12] with k = 2). Important to know is that  **k is unknown and k is much smaller than n.**  The task is to re-sort the entire array.  
The interviewer wants O(n) solution. I bombed this one. In the end, the interviewer kind of fed the solution to me. What he suggested: a. break the array into two: one sorted array and one unsorted array e.g. [1, 3, 5, 12] and [6, 4, 2]. This takes O(n) b. Sort the unsorted array. This takes O(klogk) c. Merge two sorted arrays. This takes O(n). Because k is very small, so in the end O(n) + O(klogk) ~= O(n).

Round 2: First describe a situation you missed a deadline and what you have learnt from it. Then coding question: Card has 4 attributes (color, count, shading, shape), each attribute can have value 0, 1 or 2. 3 cards are considered as a set if for each attribute, 3 cards either have the same value or have different value from each other. For example:  
card1 (2, 0, 1, 2), card2 (1, 0, 0, 1) and card3(0, 0, 2, 0) are 1 set.  
card1(2, 0, 1, 2), card2 (1, 1, 0, 1) and card3(0, 1, 2, 0) are not 1 set.

1.  write a boolean function with 3 cards as input. This function returns true if they are 1 set, otherwise returns false.
2.  Now given a collection of cards, return true if there is a set of cards exsits, otherwise return false. The interviewer wants O(n^2) solution.

Round 3: Given an array i.e. [1, 2, 3, 5, 6, 7, 8] and a value k i.e. 3. If there is a subarray with length of 2k satisfies a sequence [a, a + 1, a + 2 ... a + k - 1, b, b + 1, b + 2... b + k - 1]. Return the beginning index of this subarray. So with given array [1, 2, 3, 5, 6, 7, 8] and k = 3, it can return 0 as [1, 2, 3, 5, 6, 7] satisfies the sequence requirement. If with given array [1, 3, 5, 6, 7, 8] and k = 3, it return -1 as there is no such subarray exsits.

答案:
1. 把k个元素找出来 然后排个序 然后重新插入 n + klogk 因为k很小
2. 使用bitmask 固定中间的一张card 计算所有可能元素 应该是81种情况
3. 预处理每个元素连续的最前面的元素是多少 然后滑窗遍历 

https://leetcode.com/discuss/interview-question/1250654/google-onsite

I found this stack overflow link  [https://stackoverflow.com/questions/62764861/how-to-sort-an-array-with-n-elements-in-which-k-elements-are-out-of-place-in-on](https://stackoverflow.com/questions/62764861/how-to-sort-an-array-with-n-elements-in-which-k-elements-are-out-of-place-in-on)  which summarises the solution:

1.  Find elements which are not sorted by traversing the array.
2.  If an element was found which is larger than the next one, then either it or the following one are out of order (or both).
3.  Keep both of them aside, and remove them from the array.
4.  Continue traversing on the newly obtained array (after removal), from the index which comes before the found element.
5.  This will put aside 2k elements in O(n) time.
6.  Sort 2k elements O(klogk)
7.  Merge two sorted lists which have total n elements, O(n)  
    Total O(n + klogk)

For the above array, the resulting arrays will be - [1, 3, 12] and [5, 6, 4, 2] ( 2k elements ). I think the above will give O(n) in worst case if (k << n).

------------------------------

[Google SWE Intern OA (SEA)](https://leetcode.com/discuss/interview-question/887761/Google-SWE-Intern-OA-%28SEA%29)

![image](https://assets.leetcode.com/users/images/5b6701c8-d38f-4e4d-bbd7-1be51c03c412_1602324741.0733693.png)

答案:
The solution of Q2 (only the algorithm), to solve it in linear time, so in O(V+E).  
the drawn pictures:  [https://imgur.com/a/DHl7qZ3](https://imgur.com/a/DHl7qZ3)  
case1.  
First suppose that in G there is no directed cycle:  
In that case let u[1],u[2],...,u[k] the vertices from 1..N with income degree=0. Since we have to reach them  
we surely need to use (at least) k new added edges that ends in these points, the (income) cost of these is  
s2=cost2[u[1]]+cost2[u[2]]+...+cost2[u[k]].  
Then let t that point from the cost is the smallest, so t=argmin(cost1[1],cost1[2],...,cost1[N+1]).  
If t=N+1, then bingo, the answer is s2+k*cost1[N+1], so add the (N+1,u[i]) edges to the graph. (see first picture)  
Else, so if t<=N, then let t reachable from u[p], then add (N+1,u[p]) to the graph and  
(t,u[i]) for all i!=p, the total cost of this is s2+cost1[N+1]+(k-1)*cost1[t]. (see 2nd pic)

case2.  
There are directed cycles in the graph. Good, detect them and contract it with the following way:  
if v[1],...,v[k] is in a strongly connected component (SCC), then replace the whole component with a single P point. And update cost1[P]=min(cost1[v[1]],cost1[v[2]],..,cost1[v[k]]), and cost2[P]=min(cost2[v[1]],cost2[v[2]],...,cost2[v[k]]). At the end there will be no directed cycle in the graph, hence you can apply case1. (see 3rd pic)

--------------

[Google OA For FTE](https://leetcode.com/discuss/interview-question/1402524/Google-OA-For-FTE)

Given an array of 0, 1, and 2's find the minimum number of swaps to be performed such that A[i] = i%3 (0 <= i <= n-1) for all i. If it is not possible return -1. N <= 10^5.

注意这里的互换不要求相邻之间的元素互换 所以可以对0,1,2对应的位置计算出有多少不同的元素 比如0 计算应该是0的位置上却是1和2的个数 然后计算应该是1的位置上却是0和2的个数 最后计算应该是2的位置上却是0个1的个数 然后先互相抵消 最后就剩下
本来是 0 1 2
             1 2 0
             2 0 1

--------------

[Google | OA](https://leetcode.com/discuss/interview-question/1586927/Google-or-OA)

Write a function

class Solution { public String solution(String S); }

which, given a string S consisting of lowercase letters of the English alphabet, returns the longest consistent fragment of S which begins and ends with the same letter. If there are many possible answers you should return the one starting at the earliest position.

```
    Examples:

    1. Given S = "cbaabaab", your function should return "baabaab".

    2. Given S = "performance", your function should return "erformance".

    3. Given S = "cat", your function should return "c".

    Write an efficient algorithm for the following assumptions:

    the length of S is within the range [1..100,000];
    string S consists only of lowercase letters (a−z).
```

只有26个字母 所以只需要 看每一个字符的左右边界即可

----

[Google Interview](https://leetcode.com/discuss/interview-question/1357725/Google-Interview)

如果最左边和最右边不一样 那么直接返回
如果一样 假设为val 那么就找左边和右边第一个和val不一样的元素

---------

[Google | Phone Screen | Second Max | Reject](https://leetcode.com/discuss/interview-question/423264/Google-or-Phone-Screen-or-Second-Max-or-Reject)

Given an array of integers, find the second max using only the function  `compare(a, b)`  that compares two integers and returns the maximum of the two. The solution must use the function  `compare(a, b)`  minimum number of times.

PS: You can assume that the array doesn't contain any duplicates and all the integers are positive

```
4  7  2  0  1  3  5  6

compare adjacent:
(4  7)  (2  0)   (1  3)  (5  6)

Array after each iteration: 
(4  7)  (2  0)   (1  3)  (5  6)        4 compare()
    (7       2)      (3      6)          2 compare()
         (  7            6  )                1 compare()

```

```
4  7  2  0  1  3  5  6

compare adjacent:
(4  7)  (6  0)   (1  3)  (5  2)

Array after each iteration: 
(4  7)  (6  0)   (1  3)  (5  2)        4 compare()
    (7       6)      (3      2)          2 compare()
         (  7            2  )                1 compare()
```

注意这里不需要考虑时间复杂度 题目要求的是compare次数最少
次数最少是 n - 1 (计算最大) + logn - 1 (计算次大)
为什么两两比较不行? 两两比较计算最大也是 n - 1 但是计算次大不是logn 最好情况是O(1) 最差情况是O(n) 所以使用树形结构二分可以保证logn
[https://stackoverflow.com/questions/3628718/find-the-2nd-largest-element-in-an-array-with-minimum-number-of-comparisons](https://stackoverflow.com/questions/3628718/find-the-2nd-largest-element-in-an-array-with-minimum-number-of-comparisons)

--------------


[Google | OA | SDE (2020)| India](https://leetcode.com/discuss/interview-question/805468/Google-or-OA-or-SDE-%282020%29or-India)

You are given an array of N elements. You are allowed to delete at maximum one element from the provided array. The order of elements remains the same in the resultant array. You are required to maximize the number of subarrays that contain both maximum and minimum elements of the resultant arary.  
    **Constraints**  
    TestCases [1,10]  
    N [1,105]  
    1<= arri<=109

```
Input
6
7 2 5 4 3 1
Output
4
Explaination
If we delete 1 from the array then resultant arary will be 7 2 5 4 3. So the number of subarrays which will contain maximum 7 and minimum 2 will be 4
[7,2]
[7,2,5]
[7,2,5,4]
[7,2,5,4,3]
```

只需要找到最中间的最大值和最小值 然后就是求数量 假设位置为(i, j) 数组长为n 那么数量为 i * (1 + 2 + 3 + .... n-j) 

-------------

[Google Phone Screen Round](https://leetcode.com/discuss/interview-question/494288/Google-Phone-Screen-Round)

1.  Imagine an array class with only 3 operations GetAt(), SetAt() and SetAll(). Implement all the methods as O(1).
2.  Given denominations D and a max value MAX, find the smallest set of coins that can exactly construct any value 1 <= n <= MAX.

**_The explanation goes like this.  
D is a vector, sorted increasing, which describes the monetary system; e.g. {1, 5, 10, 25} for a U.S. penny, nickel, dime, quarter.  
MAX is in the same units as D.  
The output should be a vector of the same order as D, where each coefficient is how many of that coin you have. "Smallest set" refers to the total number of coins in the set. Some inputs may have multiple equally good answers; you may choose any such answer.

答案: 1.用一个字典存储 true false 即可
2. 油管面试题一样的 贪心思想

------------

[Google | Tree Game](https://leetcode.com/discuss/interview-question/294183/Google-or-Tree-Game)

LC version is slightly different:  [https://leetcode.com/problems/binary-tree-coloring-game](https://leetcode.com/problems/binary-tree-coloring-game)

Two people in a game, player scores by claiming nodes in binary tree.

```
class TreeNode { 
    int val; // only used to uniquely identify a node
    TreeNode parent;
    TreeNode left;
    TreeNode right;
	// you can add more fields if you want
} 

```

The player who eventually owns more nodes wins the game.  
Player A and B each claims a node at first.  
After the first round, a player will only be able to claim a node adjacent to any node owned by himself.  
A tree node is adjacent to its parent, left right and right child.  
A node owned cannot be re-claimed.  
End game when all nodes are owned.  
If player A gets the first claim at node N, find whether it is possible for player B to win.  
If yes, find out which node player B should claim at his first move.

**Follow-up:**  
If player B takes the first hand instead, which node should he pick?

答案: 一定是下在player A 的父节点 左子节点或者右子节点 分别计算对应3部分的节点数 只要比总数的一半多 那么就可以 follow up没啥意思 谁先手谁后手没区别的

-------

[Google OA 2022](https://leetcode.com/discuss/interview-question/2616381/Google-OA-2022)

This was the second question. I was not able to do this one.  
The question was as follows  
Given string of length n find alphabetically largest subsequence of length i for each i between 1 to n. [NOTE: subsequence, not subarray]  
Example:  
s = "hrw"

ans = ["w","rw","hrw"]

I don't exactly remember the constraints, but I guess n was around 1000.  
How to do this problem?  
Thanks

答案: 
TC: O(n^2)  
Extra space: O(n^2)

```
def fun(s):
    n=len(s)
    max_ij=[[-1]*n for i in range(n)] #gives the 0 based index of the max character in s[i:j+1]
    for i in range(n):
        for j in range(i,n):
            if i==j:
                max_ij[i][j]=i # initialize
            else:
                if s[j]>s[max_ij[i][j-1]]:
                    max_ij[i][j]=j # update if new max character found
                else:
                    max_ij[i][j]=max_ij[i][j-1]
    ans=[]
    for length in range(1,n+1):
        curr_ans=[]
        start=0
        for left in reversed(range(1,length+1)):
            max_index=max_ij[start][n-left] # get the max character in s[start:n-left+1] in O(1) because we still need left characters so can't utilize last left characters
            curr_ans.append(s[max_index])
            start=max_index+1
        ans.append("".join(curr_ans))
    return ans

s="hrwaw"
ans=fun(s)
print(ans)

```

Space complexity can be further reduced by using Range Query and printing output and for each length

-------------

[The Celebrity Problem](https://leetcode.com/discuss/interview-question/2607522/The-Celebrity-Problem)

**The Celebrity Problem**

_**Please upvote if you like it!!!!!!!!!!!!**_

**Problem Statement:-**  A celebrity is a person who is known to all but does not know anyone at a party. If you go to a party of N people, find if there is a celebrity in the party or not. A square NxN matrix M[][] is used to represent people at the party such that if an element of row i and column j is set to 1 it means ith person knows jth person. Here M[i][i] will always be 0.

-   Note: Follow 0 based indexing.
-   Follow Up: Can you optimize it to O(N)

**Input:**

-   N = 3
-   M[][] = {{0 1 0},  
    {0 0 0},  
    {0 1 0}}

**Output:**  1  
**Explanation:**  0th and 2nd person both know 1. Therefore, 1 is the celebrity.

**C++ Code:-**

```
//Function to find if there is a celebrity in the party or not.
    bool knows(int a, int b,vector<vector<int> >& M){
        if(M[a][b]==1) return true;
        return false;
    }
    int celebrity(vector<vector<int> >& M, int n) 
    {
        // code here 
        stack<int> st;
        for(int i=0;i<n;i++){
            st.push(i);
        }
        while(st.size()>1){
            int a=st.top();
            st.pop();
            int b=st.top();
            st.pop();
            if(knows(a,b,M))// A knows B
                st.push(b);
            else
                st.push(a);
        }
        int Candidate=st.top();
        
        //Row check
        int rowCount=0;
        for(int i=0;i<n;i++){
            if(M[Candidate][i]==0)rowCount++;
        }
        
        if(rowCount != n) return -1;
        
        //Column check
        int colCount=0;
        for(int i=0;i<n;i++){
            if(M[i][Candidate]==1) colCount++;
        }
        
        if(colCount != n-1) return -1;
        
        return Candidate;
    }
```

------

[Microsoft Online assessment question 5 tasks in 90 min](https://leetcode.com/discuss/interview-question/2214338/Microsoft-Online-assessment-question-5-tasks-in-90-min)

![image](https://assets.leetcode.com/users/images/7a823aa8-6289-4f12-b077-18baaa4e2226_1656517168.748914.png)

从小到大遍历即可 并且用一个hash表保存需要删除的元素

--------

[Microsoft | OA | Number of Slices to sort an array](https://leetcode.com/discuss/interview-question/1937426/Microsoft-or-OA-or-Number-of-Slices-to-sort-an-array)

当前区间的最大值一定要大于后面的最小值 否则就可以切割了
类似 snowflake的 array reduction

-----------

[Microsoft OA | India](https://leetcode.com/discuss/interview-question/2247302/Microsoft-OA-or-India)

[https://stackoverflow.com/questions/68859514/how-can-i-find-and-format-visually-aesthetically-pleasant-pattern-of-trees-in-a](https://stackoverflow.com/questions/68859514/how-can-i-find-and-format-visually-aesthetically-pleasant-pattern-of-trees-in-a)

There are examples of aesthetically pleasing trees:
![enter image description here](https://i.stack.imgur.com/UeWkz.png)
These are examples of not aesthetically pleasing trees
![enter image description here](https://i.stack.imgur.com/cfU5Q.png)

That, given an array A consisting of N integers, where A[K] denotes the height of the K-th three, returns the number of ways of cutting out one tree, so that the remaining trees aesthetically pleasing. If it is not possible to achieve the desired result, your function should return -1. If the trees are already aesthetically pleasing without any removal your function should return 0.

Expected Result A1 = [1, 2, 3, 4, 2, 5]; This pattern can never be form visually aesthetical so, function should return -1.

Expected Result A2 = [1, 3, 1, 2]; this pattern is already in visually aesthetically pleasant so it should return 0.

答案:
节点2一定能被删除
节点1删除 必须节点2小于节点0
节点3删除 必须节点4小于节点2

https://www.autodraw.com/share/5BK1QW1JR6E5

-----------

[Microsoft | SDE-1 | OA 2022](https://leetcode.com/discuss/interview-question/2055241/Microsoft-or-SDE-1-or-OA-2022)

**You are given a positive Integer N, your task is to find the next smallest integer greater than N that does not contain two identical consecutive digits**

ex:  **N=1765 -> 1767**  beause 1766 has two identical consecutive digits  
**N=54 -> 56**  not 55 because two identical digits

1. 如果n本身就包含2个重复的 那么找到最前面的两个相同的 如果数字不是99 那么直接第二个数字加1 后面都替换成01010101
2. 如果n本身不包含两个重复的 那么n直接加1 如果没有出现重复的 那么直接就是答案 如果出现重复的 那么就是第一种情况了

---------

[Microsoft | OA | May 2022](https://leetcode.com/discuss/interview-question/2060042/Microsoft-or-OA-or-May-2022)

![image](https://assets.leetcode.com/users/images/56105fdb-be46-47eb-8d78-cff00901dbd5_1653134827.2047198.png)

首先从左到右 如果某个5后面的数字大于5 那么就删除这个5
如果所有5的后面的数字都小于5 那么就删除最后一个5
如果5后面还是5 那么直接跳过
负数同理

-----------

[Amazon OA | September 2022](https://leetcode.com/discuss/interview-question/2532488/Amazon-OA-or-September-2022)

I got following two question in Amazon OA

-   [Minimum Swaps required to make binary string palindrome](https://devsolus.com/2022/04/26/minimum-number-of-swaps-required-to-make-a-binary-string-palindrome/)  
    e.g i/p = 11001, o/p = 1 , Explanation -> 1 swap to make 11001=>10101
-   Sum of total server power, which is the same as  [https://leetcode.com/problems/sum-of-total-strength-of-wizards/](https://leetcode.com/problems/sum-of-total-strength-of-wizards/)

------

[Tiktok OA](https://leetcode.com/discuss/interview-question/2646621/Tiktok-OA)

![image](https://assets.leetcode.com/users/images/a1eccd6f-0646-4aef-a183-00bc7c2d3790_1664640163.776837.png)

前缀和的前缀和 和那个wizard很像

------

[Google OA | step-intern](https://leetcode.com/discuss/interview-question/2675660/Google-OA-or-step-intern)

```
Q2. Given a binary array of 0s/1s count all subarrays having atleast one 0. 
Also maximum one operation is allowed to convert 1 => 0 for any element in the given array 
such that the number of subarrays with at least one 0 is maximized. 
```
011111 [1] 11110
考虑把当前的1变成0
那么新增的个数为 当前位置到前一个0的位置的距离 ✖️ 当前的位置到后一个0的距离

-----

[Google Singapore Internship OA Round for 2023 | 8th oct | Solutions attached](https://leetcode.com/discuss/interview-question/2675295/Google-Singapore-Internship-OA-Round-for-2023-or-8th-oct-or-Solutions-attached)

![image](https://assets.leetcode.com/users/images/2c40f434-2e41-4835-81ad-4fccfacab5ef_1665213558.4241586.png)

1. 考虑c上为1的bit 那么a和b都必须为1 不然的话x为1
2. 考虑c上为0的bit 那么a和b都不能同时为1 不然的话答案不存在

![image](https://assets.leetcode.com/users/images/e35f8fdf-2694-4638-ad73-744fcf440546_1665213597.7875247.png)

Q2 greedily assign the smallest digit to the alphabet with the highest coefficient

A1A + 2AB=A*111+B+210

A can not be 0 due to no leading zero, give it 1  
B is 0

------

[Salesforce | Intern | OA | 2023 | hackerrank](https://leetcode.com/discuss/interview-question/2678306/Salesforce-or-Intern-or-OA-or-2023-or-hackerrank)


<!--stackedit_data:
eyJoaXN0b3J5IjpbMTgwNzA3OTk3NiwtNDYzMjIxMTk2LDIwNj
gyMzYyOCw0Nzc1MjM4MzcsLTIzOTY0OTYyMiwtMTU1MTY0NTg5
Miw4MjcyNzI1N119
-->